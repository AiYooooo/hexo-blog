{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/anisina/source/timg.jpeg","path":"timg.jpeg","modified":0,"renderable":1},{"_id":"themes/anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8e6a74e92dfac7358375a96630c941c9589dbcaa","modified":1514253372161},{"_id":"themes/anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1499966658000},{"_id":"themes/anisina/.DS_Store","hash":"18cbf78dfd705e831d9818e021dca1b62594072c","modified":1513596570583},{"_id":"themes/anisina/README.md","hash":"ebde4101f083169abf82f5d9aa6fa34959d5cf11","modified":1499966658000},{"_id":"themes/anisina/_config.yml","hash":"06bccfc42b143659f59ea78938f00c217ac5574d","modified":1499966658000},{"_id":"themes/anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1499966658000},{"_id":"source/_posts/LeetCode_3.md","hash":"8921fb2905f969288d7a4c700adc03fd38e79013","modified":1515932463828},{"_id":"source/_posts/LeetCode_214.md","hash":"3b0e3a291ab7daaa18dbe3cc96c162b541b93a50","modified":1515932458360},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1514100954772},{"_id":"source/_posts/koa1.md","hash":"6d04584cff2f7a26362bd228c9f4e5f2c1b1f076","modified":1516176650321},{"_id":"source/_posts/node_mongoose_1.md","hash":"5eaea86ea44c9fd92bf1fd101a96541db0959631","modified":1515932468849},{"_id":"themes/anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1499966658000},{"_id":"themes/anisina/layout/.DS_Store","hash":"f60423538e7d115abf8c86b365e85ad35b418b25","modified":1499966658000},{"_id":"themes/anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1499966658000},{"_id":"themes/anisina/layout/archive.ejs","hash":"9233a4713382432b315f337adbf1db2b63082971","modified":1499966658000},{"_id":"themes/anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1499966658000},{"_id":"themes/anisina/layout/about.ejs","hash":"d409109a84aa5c032e1a230c973a91b293765176","modified":1499966658000},{"_id":"themes/anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1499966658000},{"_id":"themes/anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1499966658000},{"_id":"themes/anisina/layout/post.ejs","hash":"9427ac91b2bc36c339b528d9a569c038f0b18efa","modified":1499966658000},{"_id":"themes/anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1499966658000},{"_id":"themes/anisina/layout/page.ejs","hash":"95bbc74aa6d10cddddd7a5cd5d2a06482f5ea173","modified":1499966658000},{"_id":"themes/anisina/.idea/modules.xml","hash":"6f81355dee5b607683bdbd56595a930fb4b83c8b","modified":1499966658000},{"_id":"themes/anisina/.idea/Anisina.iml","hash":"4240dabdc746a36bae8a56eeec04a3a3fc59d842","modified":1499966658000},{"_id":"themes/anisina/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1499966658000},{"_id":"themes/anisina/layout/tags.ejs","hash":"ff363455eeddfd389ecf6c5ab090408e1d2ef4e6","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1499966658000},{"_id":"themes/anisina/.idea/workspace.xml","hash":"7c5d920658041056cc34836371895677b507001c","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1499966658000},{"_id":"themes/anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1499966658000},{"_id":"themes/anisina/source/.DS_Store","hash":"9ae5a2856d796fdb7b1849de5e23eb222df306e5","modified":1513596575587},{"_id":"themes/anisina/source/timg.jpeg","hash":"f2e04009c1e31b2ef4a6aa65ef5f81ca75ea0ea3","modified":1513596538995},{"_id":"source/Tags/index.md","hash":"1217b3da44d6a04111cde1c16e041b0c4f9ab985","modified":1513759639959},{"_id":"themes/anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1499966658000},{"_id":"themes/anisina/layout/_partial/nav.ejs","hash":"3baa41d595e951efa1db34dd1789c6f8d3b094da","modified":1499966658000},{"_id":"themes/anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1499966658000},{"_id":"themes/anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1499966658000},{"_id":"themes/anisina/layout/_partial/footer.ejs","hash":"173de3c8462ae660aa815f001b86d1e58f8cb5da","modified":1513586316990},{"_id":"themes/anisina/.idea/inspectionProfiles/Project_Default.xml","hash":"cb98213afbdfab7620cd4b6ba8801035079b4ae5","modified":1499966658000},{"_id":"themes/anisina/source/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1499966658000},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1499966658000},{"_id":"themes/anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1499966658000},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1499966658000},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1499966658000},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1499966658000},{"_id":"themes/anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1499966658000},{"_id":"themes/anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1499966658000},{"_id":"themes/anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1499966658000},{"_id":"themes/anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1499966658000},{"_id":"themes/anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1499966658000},{"_id":"themes/anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1499966658000},{"_id":"themes/anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1499966658000},{"_id":"themes/anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1499966658000},{"_id":"themes/anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1499966658000},{"_id":"themes/anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1499966658000},{"_id":"themes/anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1499966658000},{"_id":"themes/anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1499966658000},{"_id":"public/Tags/index.html","hash":"22ef53ecee873dad19be1b2a61c7e73998cf8f37","modified":1516935295159},{"_id":"public/archives/index.html","hash":"572dc18371e2844f5759bd62b6f16b28e8dc70a9","modified":1516935295159},{"_id":"public/archives/2018/index.html","hash":"bf494a68dce072f341f6a6e1723576008a4e5eb4","modified":1516935295160},{"_id":"public/tags/LeetCode/index.html","hash":"7ddc088527f9418de2d95765be98d895878d0006","modified":1516935295160},{"_id":"public/tags/Node-js/index.html","hash":"8d911b164f947501462c324b2d1f338ce6c4c125","modified":1516935295160},{"_id":"public/tags/MongoDB/index.html","hash":"27e31ea473b19a15d9219a41bcdfdf91269df0cb","modified":1516935295160},{"_id":"public/index.html","hash":"c564796b9fb195111ab601894c2c386ab0ce7e67","modified":1516935295161},{"_id":"public/archives/2017/index.html","hash":"6526b2722a9b01c0738824a1bed422787761a636","modified":1516935295159},{"_id":"public/archives/2017/12/index.html","hash":"f11115a186c1bdd0f9aae86ec6dc35b59165e9f1","modified":1516935295160},{"_id":"public/tags/Koa/index.html","hash":"4871f108d270c848ed2e1bc72caac9cd7ab6213d","modified":1516935295160},{"_id":"public/2017/12/26/LeetCode_214/index.html","hash":"c092bef25846435dbf2d9edb82e4952a4638e4c9","modified":1516935295161},{"_id":"public/2017/12/24/node_mongoose_1/index.html","hash":"ae4b825f91d54c3f9355449a68cf141e541478ce","modified":1516935295161},{"_id":"public/2017/12/20/LeetCode_3/index.html","hash":"a5444fe4c139466e6606814c8410a772d96380ac","modified":1516935295161},{"_id":"public/archives/2018/01/index.html","hash":"b44d348a7e679699e76fa87e128480ab0ae2959f","modified":1516935295160},{"_id":"public/2018/01/01/koa1/index.html","hash":"27f71d9df3dda1da98f9d2664834bc8428a76d46","modified":1516935295160},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1516935295164},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1516935295164},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1516935295164},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1516935295164},{"_id":"public/timg.jpeg","hash":"f2e04009c1e31b2ef4a6aa65ef5f81ca75ea0ea3","modified":1516935295164},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1516935295292},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1516935295296},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1516935295297},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1516935295297},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1516935295297},{"_id":"public/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1516935295297},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1516935295297},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1516935295297},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1516935295297},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1516935295297}],"Category":[],"Data":[],"Page":[{"title":"Tags","header-img":"tags.jpeg","layout":"tags","_content":"","source":"Tags/index.md","raw":"---\ntitle: Tags\nheader-img: \"tags.jpeg\"\nlayout: tags\n---\n","date":"2017-12-20T08:47:19.959Z","updated":"2017-12-20T08:47:19.959Z","path":"Tags/index.html","comments":1,"_id":"cjciskget000gn3faj2v0rnxs","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"LeetCode刷题系列(1)(question 3)","subtitle":"Longest Substring Without Repeating Characters","date":"2017-12-19T16:00:00.000Z","author":"Ai Shuangying","header-img":"hack.jpeg","cdn":"header-on","_content":"\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在[LeetCode](https://leetcode.com)上遇见的有意思、有难度或者有其他精彩答案的题目。\n所用语言为JavaScript。\n\n----------\n\n\n### 题目号码：3（medium）\n-------------\n\n\n> **Longest Substring Without Repeating Characters:**\n> Given a string, find the length of the longest substring without repeating characters.\n> \n> **Examples:**\n> - Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n> - Given \"bbbbb\", the answer is \"b\", with the length of 1.\n> - Given \"pwwkew\", the answer is \"wke\", with the length of 3.\n\n#### 题意\n返回给出字符串中最长且不含重复字母的子字符串的长度\n\n-------------\n\n#### 思路\n从字符串开头开始分析，依次找到最长的不重复字母的子字符串存储下来，遍历结束后输出其长度。\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    var result = '';\n    var data = '';\n    for(let i=0; i<s.length; i++){\n        if(data.indexOf(s.substr(i,1)) == -1){\n            data += s.substr(i,1);\n        }else{\n            if(data.length > result.length){\n                result = data;\n            }\n            data = data.substr(data.indexOf(s.substr(i,1))+1);\n            data += s.substr(i,1);\n        }\n    }\n    if(data.length > result.length){\n        result = data;\n    }\n    return result.length;\n};\n```\n\n-------------\n\n#### 分析解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let map = Array(256).fill(-1) ,cur = 0, len = 0;\n    for(let i=0;i<s.length;i++){\n        let at = s[i].charCodeAt();\n        let map_at = map[at];\n        if(map_at !== -1){cur = map_at>cur?map_at:cur;}\n        let tm_len = i-cur+1;\n        len = len>tm_len?len:tm_len;\n        map[at] = i+1;\n    }\n    return len;\n};\n```\n##### 分析如下：\n\n\t1. 变量设置\n\t\t* map：一个256长度的数组，为字母对应的Unicode编码长度，存放每个字母出现的次数\n\t\t* cur：一个遍历中的变量，存储上一个相同字母点的位置\n\t\t* len：存储每次遍历中的最长字符串长度\n\t\t* tm_len：记录实时不重复子字符串的长度\n\t2. 开始遍历给定字符串的每个字符，首先根据这个字母的Unicode编码找到这个字母在map中对应的位置的值，\n    如果这个值不为-1，说明这个字母不是第一次出现，去查找此字母的map位上的数值，\n    对应最近一次出现此字母的位置，做减法，得到此时的不重复子字符串的长度，与历史最高长度len取最大值，直至遍历结束。\n\t3. 既然不需要返回此字符串，那么就应该将逻辑聚焦在长度上，通过数组合理存储最近一次的同字母位置来完成统计。","source":"_posts/LeetCode_3.md","raw":"---\nlayout: post\ntitle: \"LeetCode刷题系列(1)(question 3)\"\nsubtitle: \"Longest Substring Without Repeating Characters\"\ndate: 2017-12-20\nauthor: \"Ai Shuangying\"\nheader-img: \"hack.jpeg\"\ncdn: 'header-on'\ntags:\n\t- LeetCode\n---\n\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在[LeetCode](https://leetcode.com)上遇见的有意思、有难度或者有其他精彩答案的题目。\n所用语言为JavaScript。\n\n----------\n\n\n### 题目号码：3（medium）\n-------------\n\n\n> **Longest Substring Without Repeating Characters:**\n> Given a string, find the length of the longest substring without repeating characters.\n> \n> **Examples:**\n> - Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n> - Given \"bbbbb\", the answer is \"b\", with the length of 1.\n> - Given \"pwwkew\", the answer is \"wke\", with the length of 3.\n\n#### 题意\n返回给出字符串中最长且不含重复字母的子字符串的长度\n\n-------------\n\n#### 思路\n从字符串开头开始分析，依次找到最长的不重复字母的子字符串存储下来，遍历结束后输出其长度。\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    var result = '';\n    var data = '';\n    for(let i=0; i<s.length; i++){\n        if(data.indexOf(s.substr(i,1)) == -1){\n            data += s.substr(i,1);\n        }else{\n            if(data.length > result.length){\n                result = data;\n            }\n            data = data.substr(data.indexOf(s.substr(i,1))+1);\n            data += s.substr(i,1);\n        }\n    }\n    if(data.length > result.length){\n        result = data;\n    }\n    return result.length;\n};\n```\n\n-------------\n\n#### 分析解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let map = Array(256).fill(-1) ,cur = 0, len = 0;\n    for(let i=0;i<s.length;i++){\n        let at = s[i].charCodeAt();\n        let map_at = map[at];\n        if(map_at !== -1){cur = map_at>cur?map_at:cur;}\n        let tm_len = i-cur+1;\n        len = len>tm_len?len:tm_len;\n        map[at] = i+1;\n    }\n    return len;\n};\n```\n##### 分析如下：\n\n\t1. 变量设置\n\t\t* map：一个256长度的数组，为字母对应的Unicode编码长度，存放每个字母出现的次数\n\t\t* cur：一个遍历中的变量，存储上一个相同字母点的位置\n\t\t* len：存储每次遍历中的最长字符串长度\n\t\t* tm_len：记录实时不重复子字符串的长度\n\t2. 开始遍历给定字符串的每个字符，首先根据这个字母的Unicode编码找到这个字母在map中对应的位置的值，\n    如果这个值不为-1，说明这个字母不是第一次出现，去查找此字母的map位上的数值，\n    对应最近一次出现此字母的位置，做减法，得到此时的不重复子字符串的长度，与历史最高长度len取最大值，直至遍历结束。\n\t3. 既然不需要返回此字符串，那么就应该将逻辑聚焦在长度上，通过数组合理存储最近一次的同字母位置来完成统计。","slug":"LeetCode_3","published":1,"updated":"2018-01-14T12:21:03.828Z","comments":1,"photos":[],"link":"","_id":"cjciskgdf0000n3fae346roxm","content":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在<a href=\"https://leetcode.com\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上遇见的有意思、有难度或者有其他精彩答案的题目。<br>所用语言为JavaScript。</p>\n<hr>\n<h3 id=\"题目号码：3（medium）\"><a href=\"#题目号码：3（medium）\" class=\"headerlink\" title=\"题目号码：3（medium）\"></a>题目号码：3（medium）</h3><hr>\n<blockquote>\n<p><strong>Longest Substring Without Repeating Characters:</strong><br>Given a string, find the length of the longest substring without repeating characters.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li>Given “abcabcbb”, the answer is “abc”, which the length is 3.</li>\n<li>Given “bbbbb”, the answer is “b”, with the length of 1.</li>\n<li>Given “pwwkew”, the answer is “wke”, with the length of 3.</li>\n</ul>\n</blockquote>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h4><p>返回给出字符串中最长且不含重复字母的子字符串的长度</p>\n<hr>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>从字符串开头开始分析，依次找到最长的不重复字母的子字符串存储下来，遍历结束后输出其长度。</p>\n<h4 id=\"我的解法\"><a href=\"#我的解法\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    var data = &apos;&apos;;</span><br><span class=\"line\">    for(let i=0; i&lt;s.length; i++)&#123;</span><br><span class=\"line\">        if(data.indexOf(s.substr(i,1)) == -1)&#123;</span><br><span class=\"line\">            data += s.substr(i,1);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            if(data.length &gt; result.length)&#123;</span><br><span class=\"line\">                result = data;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data = data.substr(data.indexOf(s.substr(i,1))+1);</span><br><span class=\"line\">            data += s.substr(i,1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(data.length &gt; result.length)&#123;</span><br><span class=\"line\">        result = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"分析解法\"><a href=\"#分析解法\" class=\"headerlink\" title=\"分析解法\"></a>分析解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    let map = Array(256).fill(-1) ,cur = 0, len = 0;</span><br><span class=\"line\">    for(let i=0;i&lt;s.length;i++)&#123;</span><br><span class=\"line\">        let at = s[i].charCodeAt();</span><br><span class=\"line\">        let map_at = map[at];</span><br><span class=\"line\">        if(map_at !== -1)&#123;cur = map_at&gt;cur?map_at:cur;&#125;</span><br><span class=\"line\">        let tm_len = i-cur+1;</span><br><span class=\"line\">        len = len&gt;tm_len?len:tm_len;</span><br><span class=\"line\">        map[at] = i+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><pre><code>1. 变量设置\n    * map：一个256长度的数组，为字母对应的Unicode编码长度，存放每个字母出现的次数\n    * cur：一个遍历中的变量，存储上一个相同字母点的位置\n    * len：存储每次遍历中的最长字符串长度\n    * tm_len：记录实时不重复子字符串的长度\n2. 开始遍历给定字符串的每个字符，首先根据这个字母的Unicode编码找到这个字母在map中对应的位置的值，\n如果这个值不为-1，说明这个字母不是第一次出现，去查找此字母的map位上的数值，\n对应最近一次出现此字母的位置，做减法，得到此时的不重复子字符串的长度，与历史最高长度len取最大值，直至遍历结束。\n3. 既然不需要返回此字符串，那么就应该将逻辑聚焦在长度上，通过数组合理存储最近一次的同字母位置来完成统计。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在<a href=\"https://leetcode.com\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上遇见的有意思、有难度或者有其他精彩答案的题目。<br>所用语言为JavaScript。</p>\n<hr>\n<h3 id=\"题目号码：3（medium）\"><a href=\"#题目号码：3（medium）\" class=\"headerlink\" title=\"题目号码：3（medium）\"></a>题目号码：3（medium）</h3><hr>\n<blockquote>\n<p><strong>Longest Substring Without Repeating Characters:</strong><br>Given a string, find the length of the longest substring without repeating characters.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li>Given “abcabcbb”, the answer is “abc”, which the length is 3.</li>\n<li>Given “bbbbb”, the answer is “b”, with the length of 1.</li>\n<li>Given “pwwkew”, the answer is “wke”, with the length of 3.</li>\n</ul>\n</blockquote>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h4><p>返回给出字符串中最长且不含重复字母的子字符串的长度</p>\n<hr>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>从字符串开头开始分析，依次找到最长的不重复字母的子字符串存储下来，遍历结束后输出其长度。</p>\n<h4 id=\"我的解法\"><a href=\"#我的解法\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    var data = &apos;&apos;;</span><br><span class=\"line\">    for(let i=0; i&lt;s.length; i++)&#123;</span><br><span class=\"line\">        if(data.indexOf(s.substr(i,1)) == -1)&#123;</span><br><span class=\"line\">            data += s.substr(i,1);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            if(data.length &gt; result.length)&#123;</span><br><span class=\"line\">                result = data;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data = data.substr(data.indexOf(s.substr(i,1))+1);</span><br><span class=\"line\">            data += s.substr(i,1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(data.length &gt; result.length)&#123;</span><br><span class=\"line\">        result = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"分析解法\"><a href=\"#分析解法\" class=\"headerlink\" title=\"分析解法\"></a>分析解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    let map = Array(256).fill(-1) ,cur = 0, len = 0;</span><br><span class=\"line\">    for(let i=0;i&lt;s.length;i++)&#123;</span><br><span class=\"line\">        let at = s[i].charCodeAt();</span><br><span class=\"line\">        let map_at = map[at];</span><br><span class=\"line\">        if(map_at !== -1)&#123;cur = map_at&gt;cur?map_at:cur;&#125;</span><br><span class=\"line\">        let tm_len = i-cur+1;</span><br><span class=\"line\">        len = len&gt;tm_len?len:tm_len;</span><br><span class=\"line\">        map[at] = i+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><pre><code>1. 变量设置\n    * map：一个256长度的数组，为字母对应的Unicode编码长度，存放每个字母出现的次数\n    * cur：一个遍历中的变量，存储上一个相同字母点的位置\n    * len：存储每次遍历中的最长字符串长度\n    * tm_len：记录实时不重复子字符串的长度\n2. 开始遍历给定字符串的每个字符，首先根据这个字母的Unicode编码找到这个字母在map中对应的位置的值，\n如果这个值不为-1，说明这个字母不是第一次出现，去查找此字母的map位上的数值，\n对应最近一次出现此字母的位置，做减法，得到此时的不重复子字符串的长度，与历史最高长度len取最大值，直至遍历结束。\n3. 既然不需要返回此字符串，那么就应该将逻辑聚焦在长度上，通过数组合理存储最近一次的同字母位置来完成统计。\n</code></pre>"},{"layout":"post","title":"LeetCode刷题系列(2)(question 214)","subtitle":"Shortest Palindrome","date":"2017-12-25T16:00:00.000Z","author":"Ai Shuangying","header-img":"hack.jpeg","cdn":"header-on","_content":"\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在[LeetCode](https://leetcode.com)上遇见的有意思、有难度或者有其他精彩答案的题目。\n所用语言为JavaScript。\n\n----------\n\n\n### 题目号码：214（hard）\n-------------\n\n\n> **Shortest Palindrome:**\n> Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. \n> Find and return the shortest palindrome you can find by performing this transformation.\n> \n> **Examples:**\n> - Given \"aacecaaa\", return \"aaacecaaa\".\n> - Given \"abcd\", return \"dcbabcd\".\n\n#### 题意\n给定一个字符串S，可以通过在它前面添加字符将其转换为回文。通过执行这个转换，找到并返回最短的回文。\n\n-------------\n\n#### 思路\n从字符串结尾开始遍历，与字符串开头对应位置的字母进行比较，如果不一致则插入一个相同的字母来形成回文\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    for(var i=s.length-1; i>=0; i--){\n        if(s[i] !== s[s.length-1-i]){\n            var s1 = s.substr(0,s.length-1-i);\n            var s2 = s.substring(s.length-1-i);\n            var ss = s[i];\n            s = ''+s1+ss+s2;\n            i++;\n        }\n    }\n    return s;\n};\n```\n##### 分析如下：\n\n但是这种解法却没有通过测试，具体情况是：\n    - 给出字符串 \"aabba\"\n    - 我的输出结果为 \"abbabba\"\n    - 期望输出结果为 \"abbaabba\"\n\n乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\n-------------\n\n#### 思路\n既然只能在给定字符串开头插入，那么就是说我需要找到给出字符串中自开头最大的回文子串，然后把剩下的字符串颠倒顺序插入即可。\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar findMaxIndex = function(s){\n    for(var i=s.length-1; i>=0; i--){\n        if(s[i] != s[s.length-1-i]){\n            return false;\n        }else{\n            continue;\n        }\n    }\n    return true;\n}\nvar shortestPalindrome = function(s) {\n    var index;\n    if(s.length == 1){ return s; }\n    for(var i=s.length; i>0; i--){\n        var s0 = s.substring(0,i);\n        if(!findMaxIndex(s0)){\n            continue;\n        }else{\n            index = i;\n            break;\n        }\n    }\n    var s1 = s.substr(0,index);\n    var s2 = s.substring(index);\n    var ss = s2.split(\"\").reverse().join(\"\");\n    return ss + s1 + s2;\n};\n```\n##### 分析如下：\n\n但是这种解法却没有通过测试，具体情况是：\n    - 超时，给出一个超长的\"aaaaaaa...aaa\"字符串\n这就要求我找到一个效率更高的解法。\n\n#### 分析解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar shortestPalindrome = function(s) {\n    var prefix = \"\";\n    var pos, head, tail;\n\n    for(pos = head = tail = parseInt(s.length / 2); pos > 0; head = tail = --pos){\n        while(head !== 0 && s[head - 1] === s[head]){\n            head--; pos--;\n        }\n        while(tail != s.length - 1 && s[tail + 1] === s[tail]){\n            tail++;\n        }\n        var isSame = true;\n        while(head >= 0){\n            if(s[head] !== s[tail]){\n                isSame = false;\n                break;\n            }\n            head--; tail++;\n        }\n        if(isSame){\n            break;\n        }\n    }\n\n    for(var k = s.length - 1; k >= tail && k !== 0; k--){\n        prefix += s[k];\n    }\n    return prefix + s;\n}\n```\n##### 分析如下：\n\n\t1. 思路：\n        * 取一个点，也就是期望的回文中心，把head和tail都指向它，先找前后相同的数，调整指针位置，然后head--, tail++这样找回文。\n        * 如果head等于0，说明找到了，倒着输出tail后面的字符加上input的字符串就是答案。\n        * 字符串中间和中间之前的点才有可能是回文的中心，后一半可以排除。\n        * 回文中心可能是单个或多个字母，如果是多个字母，他们肯定都是相同的。\n    2. 变量设置\n\t\t* prefix：用来存储原字符串中非回文部分的倒序\n\t\t* pos：回文中心点\n\t\t* head：回文头位置\n\t\t* tail：回文尾位置","source":"_posts/LeetCode_214.md","raw":"---\nlayout: post\ntitle: \"LeetCode刷题系列(2)(question 214)\"\nsubtitle: \"Shortest Palindrome\"\ndate: 2017-12-26\nauthor: \"Ai Shuangying\"\nheader-img: \"hack.jpeg\"\ncdn: 'header-on'\ntags:\n\t- LeetCode\n---\n\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在[LeetCode](https://leetcode.com)上遇见的有意思、有难度或者有其他精彩答案的题目。\n所用语言为JavaScript。\n\n----------\n\n\n### 题目号码：214（hard）\n-------------\n\n\n> **Shortest Palindrome:**\n> Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. \n> Find and return the shortest palindrome you can find by performing this transformation.\n> \n> **Examples:**\n> - Given \"aacecaaa\", return \"aaacecaaa\".\n> - Given \"abcd\", return \"dcbabcd\".\n\n#### 题意\n给定一个字符串S，可以通过在它前面添加字符将其转换为回文。通过执行这个转换，找到并返回最短的回文。\n\n-------------\n\n#### 思路\n从字符串结尾开始遍历，与字符串开头对应位置的字母进行比较，如果不一致则插入一个相同的字母来形成回文\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    for(var i=s.length-1; i>=0; i--){\n        if(s[i] !== s[s.length-1-i]){\n            var s1 = s.substr(0,s.length-1-i);\n            var s2 = s.substring(s.length-1-i);\n            var ss = s[i];\n            s = ''+s1+ss+s2;\n            i++;\n        }\n    }\n    return s;\n};\n```\n##### 分析如下：\n\n但是这种解法却没有通过测试，具体情况是：\n    - 给出字符串 \"aabba\"\n    - 我的输出结果为 \"abbabba\"\n    - 期望输出结果为 \"abbaabba\"\n\n乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\n-------------\n\n#### 思路\n既然只能在给定字符串开头插入，那么就是说我需要找到给出字符串中自开头最大的回文子串，然后把剩下的字符串颠倒顺序插入即可。\n\n#### 我的解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar findMaxIndex = function(s){\n    for(var i=s.length-1; i>=0; i--){\n        if(s[i] != s[s.length-1-i]){\n            return false;\n        }else{\n            continue;\n        }\n    }\n    return true;\n}\nvar shortestPalindrome = function(s) {\n    var index;\n    if(s.length == 1){ return s; }\n    for(var i=s.length; i>0; i--){\n        var s0 = s.substring(0,i);\n        if(!findMaxIndex(s0)){\n            continue;\n        }else{\n            index = i;\n            break;\n        }\n    }\n    var s1 = s.substr(0,index);\n    var s2 = s.substring(index);\n    var ss = s2.split(\"\").reverse().join(\"\");\n    return ss + s1 + s2;\n};\n```\n##### 分析如下：\n\n但是这种解法却没有通过测试，具体情况是：\n    - 超时，给出一个超长的\"aaaaaaa...aaa\"字符串\n这就要求我找到一个效率更高的解法。\n\n#### 分析解法\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar shortestPalindrome = function(s) {\n    var prefix = \"\";\n    var pos, head, tail;\n\n    for(pos = head = tail = parseInt(s.length / 2); pos > 0; head = tail = --pos){\n        while(head !== 0 && s[head - 1] === s[head]){\n            head--; pos--;\n        }\n        while(tail != s.length - 1 && s[tail + 1] === s[tail]){\n            tail++;\n        }\n        var isSame = true;\n        while(head >= 0){\n            if(s[head] !== s[tail]){\n                isSame = false;\n                break;\n            }\n            head--; tail++;\n        }\n        if(isSame){\n            break;\n        }\n    }\n\n    for(var k = s.length - 1; k >= tail && k !== 0; k--){\n        prefix += s[k];\n    }\n    return prefix + s;\n}\n```\n##### 分析如下：\n\n\t1. 思路：\n        * 取一个点，也就是期望的回文中心，把head和tail都指向它，先找前后相同的数，调整指针位置，然后head--, tail++这样找回文。\n        * 如果head等于0，说明找到了，倒着输出tail后面的字符加上input的字符串就是答案。\n        * 字符串中间和中间之前的点才有可能是回文的中心，后一半可以排除。\n        * 回文中心可能是单个或多个字母，如果是多个字母，他们肯定都是相同的。\n    2. 变量设置\n\t\t* prefix：用来存储原字符串中非回文部分的倒序\n\t\t* pos：回文中心点\n\t\t* head：回文头位置\n\t\t* tail：回文尾位置","slug":"LeetCode_214","published":1,"updated":"2018-01-14T12:20:58.360Z","comments":1,"photos":[],"link":"","_id":"cjciskgdk0001n3fa8l72gip3","content":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在<a href=\"https://leetcode.com\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上遇见的有意思、有难度或者有其他精彩答案的题目。<br>所用语言为JavaScript。</p>\n<hr>\n<h3 id=\"题目号码：214（hard）\"><a href=\"#题目号码：214（hard）\" class=\"headerlink\" title=\"题目号码：214（hard）\"></a>题目号码：214（hard）</h3><hr>\n<blockquote>\n<p><strong>Shortest Palindrome:</strong><br>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it.<br>Find and return the shortest palindrome you can find by performing this transformation.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li>Given “aacecaaa”, return “aaacecaaa”.</li>\n<li>Given “abcd”, return “dcbabcd”.</li>\n</ul>\n</blockquote>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h4><p>给定一个字符串S，可以通过在它前面添加字符将其转换为回文。通过执行这个转换，找到并返回最短的回文。</p>\n<hr>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>从字符串结尾开始遍历，与字符串开头对应位置的字母进行比较，如果不一致则插入一个相同的字母来形成回文</p>\n<h4 id=\"我的解法\"><a href=\"#我的解法\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    for(var i=s.length-1; i&gt;=0; i--)&#123;</span><br><span class=\"line\">        if(s[i] !== s[s.length-1-i])&#123;</span><br><span class=\"line\">            var s1 = s.substr(0,s.length-1-i);</span><br><span class=\"line\">            var s2 = s.substring(s.length-1-i);</span><br><span class=\"line\">            var ss = s[i];</span><br><span class=\"line\">            s = &apos;&apos;+s1+ss+s2;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><p>但是这种解法却没有通过测试，具体情况是：</p>\n<pre><code>- 给出字符串 &quot;aabba&quot;\n- 我的输出结果为 &quot;abbabba&quot;\n- 期望输出结果为 &quot;abbaabba&quot;\n</code></pre><h2 id=\"乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\"><a href=\"#乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\" class=\"headerlink\" title=\"乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\"></a>乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。</h2><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>既然只能在给定字符串开头插入，那么就是说我需要找到给出字符串中自开头最大的回文子串，然后把剩下的字符串颠倒顺序插入即可。</p>\n<h4 id=\"我的解法-1\"><a href=\"#我的解法-1\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var findMaxIndex = function(s)&#123;</span><br><span class=\"line\">    for(var i=s.length-1; i&gt;=0; i--)&#123;</span><br><span class=\"line\">        if(s[i] != s[s.length-1-i])&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var shortestPalindrome = function(s) &#123;</span><br><span class=\"line\">    var index;</span><br><span class=\"line\">    if(s.length == 1)&#123; return s; &#125;</span><br><span class=\"line\">    for(var i=s.length; i&gt;0; i--)&#123;</span><br><span class=\"line\">        var s0 = s.substring(0,i);</span><br><span class=\"line\">        if(!findMaxIndex(s0))&#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            index = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var s1 = s.substr(0,index);</span><br><span class=\"line\">    var s2 = s.substring(index);</span><br><span class=\"line\">    var ss = s2.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class=\"line\">    return ss + s1 + s2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：-1\"><a href=\"#分析如下：-1\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><p>但是这种解法却没有通过测试，具体情况是：</p>\n<pre><code>- 超时，给出一个超长的&quot;aaaaaaa...aaa&quot;字符串\n</code></pre><p>这就要求我找到一个效率更高的解法。</p>\n<h4 id=\"分析解法\"><a href=\"#分析解法\" class=\"headerlink\" title=\"分析解法\"></a>分析解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var shortestPalindrome = function(s) &#123;</span><br><span class=\"line\">    var prefix = &quot;&quot;;</span><br><span class=\"line\">    var pos, head, tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(pos = head = tail = parseInt(s.length / 2); pos &gt; 0; head = tail = --pos)&#123;</span><br><span class=\"line\">        while(head !== 0 &amp;&amp; s[head - 1] === s[head])&#123;</span><br><span class=\"line\">            head--; pos--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while(tail != s.length - 1 &amp;&amp; s[tail + 1] === s[tail])&#123;</span><br><span class=\"line\">            tail++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var isSame = true;</span><br><span class=\"line\">        while(head &gt;= 0)&#123;</span><br><span class=\"line\">            if(s[head] !== s[tail])&#123;</span><br><span class=\"line\">                isSame = false;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head--; tail++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(isSame)&#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(var k = s.length - 1; k &gt;= tail &amp;&amp; k !== 0; k--)&#123;</span><br><span class=\"line\">        prefix += s[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return prefix + s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：-2\"><a href=\"#分析如下：-2\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><pre><code>1. 思路：\n    * 取一个点，也就是期望的回文中心，把head和tail都指向它，先找前后相同的数，调整指针位置，然后head--, tail++这样找回文。\n    * 如果head等于0，说明找到了，倒着输出tail后面的字符加上input的字符串就是答案。\n    * 字符串中间和中间之前的点才有可能是回文的中心，后一半可以排除。\n    * 回文中心可能是单个或多个字母，如果是多个字母，他们肯定都是相同的。\n2. 变量设置\n    * prefix：用来存储原字符串中非回文部分的倒序\n    * pos：回文中心点\n    * head：回文头位置\n    * tail：回文尾位置\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在<a href=\"https://leetcode.com\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上遇见的有意思、有难度或者有其他精彩答案的题目。<br>所用语言为JavaScript。</p>\n<hr>\n<h3 id=\"题目号码：214（hard）\"><a href=\"#题目号码：214（hard）\" class=\"headerlink\" title=\"题目号码：214（hard）\"></a>题目号码：214（hard）</h3><hr>\n<blockquote>\n<p><strong>Shortest Palindrome:</strong><br>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it.<br>Find and return the shortest palindrome you can find by performing this transformation.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li>Given “aacecaaa”, return “aaacecaaa”.</li>\n<li>Given “abcd”, return “dcbabcd”.</li>\n</ul>\n</blockquote>\n<h4 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h4><p>给定一个字符串S，可以通过在它前面添加字符将其转换为回文。通过执行这个转换，找到并返回最短的回文。</p>\n<hr>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>从字符串结尾开始遍历，与字符串开头对应位置的字母进行比较，如果不一致则插入一个相同的字母来形成回文</p>\n<h4 id=\"我的解法\"><a href=\"#我的解法\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">    for(var i=s.length-1; i&gt;=0; i--)&#123;</span><br><span class=\"line\">        if(s[i] !== s[s.length-1-i])&#123;</span><br><span class=\"line\">            var s1 = s.substr(0,s.length-1-i);</span><br><span class=\"line\">            var s2 = s.substring(s.length-1-i);</span><br><span class=\"line\">            var ss = s[i];</span><br><span class=\"line\">            s = &apos;&apos;+s1+ss+s2;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><p>但是这种解法却没有通过测试，具体情况是：</p>\n<pre><code>- 给出字符串 &quot;aabba&quot;\n- 我的输出结果为 &quot;abbabba&quot;\n- 期望输出结果为 &quot;abbaabba&quot;\n</code></pre><h2 id=\"乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\"><a href=\"#乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\" class=\"headerlink\" title=\"乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。\"></a>乍一看仿佛是我的结果更准确，但是回过头仔细审题会发现题目中要求的是“在它前面添加字符”来形成回文，即我的解法思路是错的。</h2><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>既然只能在给定字符串开头插入，那么就是说我需要找到给出字符串中自开头最大的回文子串，然后把剩下的字符串颠倒顺序插入即可。</p>\n<h4 id=\"我的解法-1\"><a href=\"#我的解法-1\" class=\"headerlink\" title=\"我的解法\"></a>我的解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var findMaxIndex = function(s)&#123;</span><br><span class=\"line\">    for(var i=s.length-1; i&gt;=0; i--)&#123;</span><br><span class=\"line\">        if(s[i] != s[s.length-1-i])&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var shortestPalindrome = function(s) &#123;</span><br><span class=\"line\">    var index;</span><br><span class=\"line\">    if(s.length == 1)&#123; return s; &#125;</span><br><span class=\"line\">    for(var i=s.length; i&gt;0; i--)&#123;</span><br><span class=\"line\">        var s0 = s.substring(0,i);</span><br><span class=\"line\">        if(!findMaxIndex(s0))&#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            index = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var s1 = s.substr(0,index);</span><br><span class=\"line\">    var s2 = s.substring(index);</span><br><span class=\"line\">    var ss = s2.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class=\"line\">    return ss + s1 + s2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：-1\"><a href=\"#分析如下：-1\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><p>但是这种解法却没有通过测试，具体情况是：</p>\n<pre><code>- 超时，给出一个超长的&quot;aaaaaaa...aaa&quot;字符串\n</code></pre><p>这就要求我找到一个效率更高的解法。</p>\n<h4 id=\"分析解法\"><a href=\"#分析解法\" class=\"headerlink\" title=\"分析解法\"></a>分析解法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; s</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var shortestPalindrome = function(s) &#123;</span><br><span class=\"line\">    var prefix = &quot;&quot;;</span><br><span class=\"line\">    var pos, head, tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(pos = head = tail = parseInt(s.length / 2); pos &gt; 0; head = tail = --pos)&#123;</span><br><span class=\"line\">        while(head !== 0 &amp;&amp; s[head - 1] === s[head])&#123;</span><br><span class=\"line\">            head--; pos--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while(tail != s.length - 1 &amp;&amp; s[tail + 1] === s[tail])&#123;</span><br><span class=\"line\">            tail++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var isSame = true;</span><br><span class=\"line\">        while(head &gt;= 0)&#123;</span><br><span class=\"line\">            if(s[head] !== s[tail])&#123;</span><br><span class=\"line\">                isSame = false;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head--; tail++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(isSame)&#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(var k = s.length - 1; k &gt;= tail &amp;&amp; k !== 0; k--)&#123;</span><br><span class=\"line\">        prefix += s[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return prefix + s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析如下：-2\"><a href=\"#分析如下：-2\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h5><pre><code>1. 思路：\n    * 取一个点，也就是期望的回文中心，把head和tail都指向它，先找前后相同的数，调整指针位置，然后head--, tail++这样找回文。\n    * 如果head等于0，说明找到了，倒着输出tail后面的字符加上input的字符串就是答案。\n    * 字符串中间和中间之前的点才有可能是回文的中心，后一半可以排除。\n    * 回文中心可能是单个或多个字母，如果是多个字母，他们肯定都是相同的。\n2. 变量设置\n    * prefix：用来存储原字符串中非回文部分的倒序\n    * pos：回文中心点\n    * head：回文头位置\n    * tail：回文尾位置\n</code></pre>"},{"layout":"post","title":"Koa学习笔记 一","subtitle":"基本用法","date":"2017-12-31T16:00:00.000Z","author":"Ai Shuangying","header-img":"hack.jpeg","cdn":"header-on","_content":"\n\n这个系列将记载我在学习Koa过程中需要记录下来的重点和遇到的问题。\n[中文文档](https://koa.bootcss.com/)\n[英文文档](http://koajs.com)\n\n----------\n\n### 安装koa\n-------------\n\nKoa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持\n\n这里提供将升级本地node版本的方法\n\n先查看本机node.js版本：\n\n```\n    $ node -v\n```\n\n清除node.js的cache：(此步会要求输入密码)\n\n```\n    $ sudo npm cache clean -f\n```\n\n安装 n 工具，这个工具是专门用来管理node.js版本的\n\n```\n    $ sudo npm install -g n\n```\n\n安装最新版本的node.js\n\n```\n    $ sudo n stable\n```\n\n再次查看本机的node.js版本：(本文采用的node版本为9.4.0)\n\n```\n    $ node -v\n```\n\n安装koa\n\n```\n    $ npm i koa\n```\n\n\n### 架设HTTP服务\n-------------\n\n```\n    const Koa = require('koa');\n\tconst app = new Koa();\n\n\tapp.listen(3000);\n```\n\n这里的 app.listen(...) 方法只是以下方法的语法糖:\n\n```\n    const http = require('http');\n\tconst Koa = require('koa');\n\tconst app = new Koa();\n\thttp.createServer(app.callback()).listen(3000);\n```\n\n这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：\n\n```\n    const http = require('http');\n\tconst https = require('https');\n\tconst Koa = require('koa');\n\tconst app = new Koa();\n\thttp.createServer(app.callback()).listen(3000);\n\thttps.createServer(app.callback()).listen(3001);\n```\n\n\n### 上下文对象 Context\n-------------\n\nKoa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。\n\n```\n\tapp.use(async ctx => {\n\t  \tctx; \t\t\t// 这是 Context\n\t  \tctx.req; \t\t// 这是 Node Request\n\t  \tctx.res; \t\t// 这是 Node Response  绕过 Koa 的 response 处理是 不被支持的. \n\t  \tctx.request; \t// 这是 koa Request\n\t  \tctx.response; \t// 这是 koa Response\n\n\t  \tctx.request.header   \t//请求标头对象。\n\t  \tctx.request.header=   \t//设置请求标头对象。\n\t  \tctx.request.method   \t//请求方法。\n\t  \tctx.request.method=   \t//设置请求方法，对于实现诸如 methodOverride() 的中间件是有用的。\n\t  \tctx.request.length   \t//返回以数字返回请求的 Content-Length，或 undefined。\n\t  \tctx.request.url   \t\t//获取请求 URL.\n\t  \tctx.request.url=    \t//设置请求 URL, 对 url 重写有用。\n\t  \tctx.request.origin   \t//获取URL的来源，包括 protocol 和 host。\n\t  \tctx.request.href    \t//获取完整的请求URL，包括 protocol，host 和 url。\n\t  \tctx.request.path   \t    //获取请求路径名。\n\t  \tctx.request.querystring //根据 ? 获取原始查询字符串.\n\t  \tctx.request.search   \t//使用 ? 获取原始查询字符串。\n\t  \tctx.request.query   \t//获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter 不 支持嵌套解析。\n\t});\n```\n\nContext.response.body属性就是发送给用户的内容。\n\n```\n    const Koa = require('koa');\n\tconst app = new Koa();\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\tapp.use(main);\n\tapp.listen(3000);\n```\n\n```\n    ctx.response.type = 'json / xml / html / text'; //这些都是response的类型\n```\n\n```\n    const main = ctx => {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = fs.createReadStream('./demos/template.html');\n\t};    //返回一个网页模板\n```\n\nctx.cookies用来读写 Cookie\n\n```\n\tconst main = function(ctx) {\n  \t\tconst n = Number(ctx.cookies.get('view') || 0) + 1;\n  \t\tctx.cookies.set('view', n);\n  \t\tctx.response.body = n + ' views';\n\t}\n```\n\n### 路由\n-------------\n\n这里使用koa自带的koa-route 模块\n\n```\n    const route = require('koa-route');\n\n\tconst about = ctx => {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = '<a href=\"/\">Index Page</a>';\n\t};\n\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\n\tapp.use(route.get('/', main));\n\tapp.use(route.get('/about', about));\n```\n\n静态资源访问则使用koa自带的koa-static模块\n\n```\n    const path = require('path');\n\tconst serve = require('koa-static');\n\n\tconst main = serve(path.join(__dirname));\n\tapp.use(main);\n```\n\n重定向\n\n```\n    const redirect = ctx => {\n  \t\tctx.response.redirect('/');\n  \t\tctx.response.body = '<a href=\"/\">Index Page</a>';\n\t};\n\n\tapp.use(route.get('/redirect', redirect));  //访问'/redirect'的请求会被重定向到'/'\n```\n\n\n### 中间件\n-------------\n\n基本上，Koa 所有的功能都是通过中间件实现的。\n中间件的实现很简单，所谓中间件可以看做是有两个参数的函数，用来在 HTTP Request 和 HTTP Response 中间实现某种功能。\n\n```\n\t//一个非常简单的输出log的中间件函数\n    const logger = (ctx, next) => {\n  \t\tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  \t\tnext();\n\t}\n\tapp.use(logger);\n```\n\n如果对进程添加很多中间件的话会怎么样呢？\n多个中间件会形成一个栈结构（middle stack），以\"先进后出\"（first-in-last-out）的顺序执行。\n\n也就是说，会从上至下依次进入每个中间件，但只有在最内层中间件执行完毕后才会一层层返回到最外层中间件，示例如下：\n\n```\n\tconst one = (ctx, next) => {\n\t  \tconsole.log('>> one');\n\t  \tnext();\n\t  \tconsole.log('<< one');\n\t}\n\tconst two = (ctx, next) => {\n\t  \tconsole.log('>> two');\n\t  \tnext(); \n\t  \tconsole.log('<< two');\n\t}\n\tconst three = (ctx, next) => {\n\t  \tconsole.log('>> three');\n\t  \tnext();\n\t  \tconsole.log('<< three');\n\t}\n\n\tapp.use(one);\n\tapp.use(two);\n\tapp.use(three);\n```\n\n此时的输出应该是\n\n```\n\t>> one\n\t>> two\n\t>> three\n\t<< three\n\t<< two\n\t<< one\n```\n\n这是全同步中间件的执行流程，如果这些中间件中包含异步操作，那么执行的流程就会发生变化\n\n首先，包含异步操作的中间件必须写成async函数\n\n```\n\t//这就是一个异步中间件\n\tconst main = async function (ctx, next) {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = await fs.readFile('./demos/template.html', 'utf8');\n\t};\n\n\tapp.use(main);\n```\n\n中间件的合成则可以使用 koa-compose 模块\n\n```\n\tconst compose = require('koa-compose');\n\n\tconst logger = (ctx, next) => {\n\t  \tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n\t  \tnext();\n\t}\n\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\n\tconst middlewares = compose([logger, main]);\n\tapp.use(middlewares);\n```\n\n从 POST 请求的数据体里面提取键值对使用 koa-body 模块\n\n```\n\tconst koaBody = require('koa-body');\n\n\tconst main = async function(ctx) {\n\t  \tconst body = ctx.request.body;\n\t  \tif (!body.name) ctx.throw(400, '.name required');\n\t  \tctx.body = { name: body.name };\n\t};\n\n\tapp.use(koaBody());\n```\n\n\n\n### 错误处理\n-------------\n\n直接抛出错误\n\n```\n\tconst main = ctx => {\n  \t\tctx.throw(500);\n\t};\n```\n\n返回错误\n\n```\n\tconst main = ctx => {\n  \t\tctx.response.status = 404;\n  \t\tctx.response.body = 'Page Not Found';\n\t};\n```\n\n为了方便处理错误，最好使用try...catch将其捕获。但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。\n\n```\n\tconst handler = async (ctx, next) => {\n\t  \ttry {\n\t    \tawait next();\n\t  \t}catch (err) {\n\t    \tctx.response.status = err.statusCode || err.status || 500;\n\t    \tctx.response.body = {\n\t      \t\tmessage: err.message\n\t    \t};\n\t  \t}\n\t};\n\n\tconst main = ctx => {\n\t  \tctx.throw(500);\n\t};\n\n\tapp.use(handler);\n\tapp.use(main);\n```\n\napp监听错误的处理方法\n\n```\n\tapp.on('error', (err, ctx) =>\n  \t\tconsole.error('server error', err);\n\t);\n```\n\n需要注意的是，如果错误被try...catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。\n\n```\n\tconst handler = async (ctx, next) => {\n\t  \ttry {\n\t    \tawait next();\n\t  \t} catch (err) {\n\t    \tctx.response.status = err.statusCode || err.status || 500;\n\t    \tctx.response.type = 'html';\n\t    \tctx.response.body = '<p>Something wrong, please contact administrator.</p>';\n\t    \tctx.app.emit('error', err, ctx);\n\t  \t}\n\t};\n```\n\n\n参考：\n[阮一峰koa教程](http://www.ruanyifeng.com/blog/2017/08/koa.html)\n","source":"_posts/koa1.md","raw":"---\nlayout: post\ntitle: \"Koa学习笔记 一\"\nsubtitle: \"基本用法\"\ndate: 2018-1-1\nauthor: \"Ai Shuangying\"\nheader-img: \"hack.jpeg\"\ncdn: 'header-on'\ntags: \n    - Node.js\n    - Koa\n---\n\n\n这个系列将记载我在学习Koa过程中需要记录下来的重点和遇到的问题。\n[中文文档](https://koa.bootcss.com/)\n[英文文档](http://koajs.com)\n\n----------\n\n### 安装koa\n-------------\n\nKoa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持\n\n这里提供将升级本地node版本的方法\n\n先查看本机node.js版本：\n\n```\n    $ node -v\n```\n\n清除node.js的cache：(此步会要求输入密码)\n\n```\n    $ sudo npm cache clean -f\n```\n\n安装 n 工具，这个工具是专门用来管理node.js版本的\n\n```\n    $ sudo npm install -g n\n```\n\n安装最新版本的node.js\n\n```\n    $ sudo n stable\n```\n\n再次查看本机的node.js版本：(本文采用的node版本为9.4.0)\n\n```\n    $ node -v\n```\n\n安装koa\n\n```\n    $ npm i koa\n```\n\n\n### 架设HTTP服务\n-------------\n\n```\n    const Koa = require('koa');\n\tconst app = new Koa();\n\n\tapp.listen(3000);\n```\n\n这里的 app.listen(...) 方法只是以下方法的语法糖:\n\n```\n    const http = require('http');\n\tconst Koa = require('koa');\n\tconst app = new Koa();\n\thttp.createServer(app.callback()).listen(3000);\n```\n\n这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：\n\n```\n    const http = require('http');\n\tconst https = require('https');\n\tconst Koa = require('koa');\n\tconst app = new Koa();\n\thttp.createServer(app.callback()).listen(3000);\n\thttps.createServer(app.callback()).listen(3001);\n```\n\n\n### 上下文对象 Context\n-------------\n\nKoa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。\n\n```\n\tapp.use(async ctx => {\n\t  \tctx; \t\t\t// 这是 Context\n\t  \tctx.req; \t\t// 这是 Node Request\n\t  \tctx.res; \t\t// 这是 Node Response  绕过 Koa 的 response 处理是 不被支持的. \n\t  \tctx.request; \t// 这是 koa Request\n\t  \tctx.response; \t// 这是 koa Response\n\n\t  \tctx.request.header   \t//请求标头对象。\n\t  \tctx.request.header=   \t//设置请求标头对象。\n\t  \tctx.request.method   \t//请求方法。\n\t  \tctx.request.method=   \t//设置请求方法，对于实现诸如 methodOverride() 的中间件是有用的。\n\t  \tctx.request.length   \t//返回以数字返回请求的 Content-Length，或 undefined。\n\t  \tctx.request.url   \t\t//获取请求 URL.\n\t  \tctx.request.url=    \t//设置请求 URL, 对 url 重写有用。\n\t  \tctx.request.origin   \t//获取URL的来源，包括 protocol 和 host。\n\t  \tctx.request.href    \t//获取完整的请求URL，包括 protocol，host 和 url。\n\t  \tctx.request.path   \t    //获取请求路径名。\n\t  \tctx.request.querystring //根据 ? 获取原始查询字符串.\n\t  \tctx.request.search   \t//使用 ? 获取原始查询字符串。\n\t  \tctx.request.query   \t//获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter 不 支持嵌套解析。\n\t});\n```\n\nContext.response.body属性就是发送给用户的内容。\n\n```\n    const Koa = require('koa');\n\tconst app = new Koa();\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\tapp.use(main);\n\tapp.listen(3000);\n```\n\n```\n    ctx.response.type = 'json / xml / html / text'; //这些都是response的类型\n```\n\n```\n    const main = ctx => {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = fs.createReadStream('./demos/template.html');\n\t};    //返回一个网页模板\n```\n\nctx.cookies用来读写 Cookie\n\n```\n\tconst main = function(ctx) {\n  \t\tconst n = Number(ctx.cookies.get('view') || 0) + 1;\n  \t\tctx.cookies.set('view', n);\n  \t\tctx.response.body = n + ' views';\n\t}\n```\n\n### 路由\n-------------\n\n这里使用koa自带的koa-route 模块\n\n```\n    const route = require('koa-route');\n\n\tconst about = ctx => {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = '<a href=\"/\">Index Page</a>';\n\t};\n\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\n\tapp.use(route.get('/', main));\n\tapp.use(route.get('/about', about));\n```\n\n静态资源访问则使用koa自带的koa-static模块\n\n```\n    const path = require('path');\n\tconst serve = require('koa-static');\n\n\tconst main = serve(path.join(__dirname));\n\tapp.use(main);\n```\n\n重定向\n\n```\n    const redirect = ctx => {\n  \t\tctx.response.redirect('/');\n  \t\tctx.response.body = '<a href=\"/\">Index Page</a>';\n\t};\n\n\tapp.use(route.get('/redirect', redirect));  //访问'/redirect'的请求会被重定向到'/'\n```\n\n\n### 中间件\n-------------\n\n基本上，Koa 所有的功能都是通过中间件实现的。\n中间件的实现很简单，所谓中间件可以看做是有两个参数的函数，用来在 HTTP Request 和 HTTP Response 中间实现某种功能。\n\n```\n\t//一个非常简单的输出log的中间件函数\n    const logger = (ctx, next) => {\n  \t\tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  \t\tnext();\n\t}\n\tapp.use(logger);\n```\n\n如果对进程添加很多中间件的话会怎么样呢？\n多个中间件会形成一个栈结构（middle stack），以\"先进后出\"（first-in-last-out）的顺序执行。\n\n也就是说，会从上至下依次进入每个中间件，但只有在最内层中间件执行完毕后才会一层层返回到最外层中间件，示例如下：\n\n```\n\tconst one = (ctx, next) => {\n\t  \tconsole.log('>> one');\n\t  \tnext();\n\t  \tconsole.log('<< one');\n\t}\n\tconst two = (ctx, next) => {\n\t  \tconsole.log('>> two');\n\t  \tnext(); \n\t  \tconsole.log('<< two');\n\t}\n\tconst three = (ctx, next) => {\n\t  \tconsole.log('>> three');\n\t  \tnext();\n\t  \tconsole.log('<< three');\n\t}\n\n\tapp.use(one);\n\tapp.use(two);\n\tapp.use(three);\n```\n\n此时的输出应该是\n\n```\n\t>> one\n\t>> two\n\t>> three\n\t<< three\n\t<< two\n\t<< one\n```\n\n这是全同步中间件的执行流程，如果这些中间件中包含异步操作，那么执行的流程就会发生变化\n\n首先，包含异步操作的中间件必须写成async函数\n\n```\n\t//这就是一个异步中间件\n\tconst main = async function (ctx, next) {\n\t  \tctx.response.type = 'html';\n\t  \tctx.response.body = await fs.readFile('./demos/template.html', 'utf8');\n\t};\n\n\tapp.use(main);\n```\n\n中间件的合成则可以使用 koa-compose 模块\n\n```\n\tconst compose = require('koa-compose');\n\n\tconst logger = (ctx, next) => {\n\t  \tconsole.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n\t  \tnext();\n\t}\n\n\tconst main = ctx => {\n\t  \tctx.response.body = 'Hello World';\n\t};\n\n\tconst middlewares = compose([logger, main]);\n\tapp.use(middlewares);\n```\n\n从 POST 请求的数据体里面提取键值对使用 koa-body 模块\n\n```\n\tconst koaBody = require('koa-body');\n\n\tconst main = async function(ctx) {\n\t  \tconst body = ctx.request.body;\n\t  \tif (!body.name) ctx.throw(400, '.name required');\n\t  \tctx.body = { name: body.name };\n\t};\n\n\tapp.use(koaBody());\n```\n\n\n\n### 错误处理\n-------------\n\n直接抛出错误\n\n```\n\tconst main = ctx => {\n  \t\tctx.throw(500);\n\t};\n```\n\n返回错误\n\n```\n\tconst main = ctx => {\n  \t\tctx.response.status = 404;\n  \t\tctx.response.body = 'Page Not Found';\n\t};\n```\n\n为了方便处理错误，最好使用try...catch将其捕获。但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。\n\n```\n\tconst handler = async (ctx, next) => {\n\t  \ttry {\n\t    \tawait next();\n\t  \t}catch (err) {\n\t    \tctx.response.status = err.statusCode || err.status || 500;\n\t    \tctx.response.body = {\n\t      \t\tmessage: err.message\n\t    \t};\n\t  \t}\n\t};\n\n\tconst main = ctx => {\n\t  \tctx.throw(500);\n\t};\n\n\tapp.use(handler);\n\tapp.use(main);\n```\n\napp监听错误的处理方法\n\n```\n\tapp.on('error', (err, ctx) =>\n  \t\tconsole.error('server error', err);\n\t);\n```\n\n需要注意的是，如果错误被try...catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。\n\n```\n\tconst handler = async (ctx, next) => {\n\t  \ttry {\n\t    \tawait next();\n\t  \t} catch (err) {\n\t    \tctx.response.status = err.statusCode || err.status || 500;\n\t    \tctx.response.type = 'html';\n\t    \tctx.response.body = '<p>Something wrong, please contact administrator.</p>';\n\t    \tctx.app.emit('error', err, ctx);\n\t  \t}\n\t};\n```\n\n\n参考：\n[阮一峰koa教程](http://www.ruanyifeng.com/blog/2017/08/koa.html)\n","slug":"koa1","published":1,"updated":"2018-01-17T08:10:50.321Z","comments":1,"photos":[],"link":"","_id":"cjciskgdo0003n3facwxcti62","content":"<p>这个系列将记载我在学习Koa过程中需要记录下来的重点和遇到的问题。<br><a href=\"https://koa.bootcss.com/\" target=\"_blank\" rel=\"noopener\">中文文档</a><br><a href=\"http://koajs.com\" target=\"_blank\" rel=\"noopener\">英文文档</a></p>\n<hr>\n<h3 id=\"安装koa\"><a href=\"#安装koa\" class=\"headerlink\" title=\"安装koa\"></a>安装koa</h3><hr>\n<p>Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持</p>\n<p>这里提供将升级本地node版本的方法</p>\n<p>先查看本机node.js版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n<p>清除node.js的cache：(此步会要求输入密码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm cache clean -f</span><br></pre></td></tr></table></figure>\n<p>安装 n 工具，这个工具是专门用来管理node.js版本的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g n</span><br></pre></td></tr></table></figure>\n<p>安装最新版本的node.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo n stable</span><br></pre></td></tr></table></figure>\n<p>再次查看本机的node.js版本：(本文采用的node版本为9.4.0)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n<p>安装koa</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i koa</span><br></pre></td></tr></table></figure>\n<h3 id=\"架设HTTP服务\"><a href=\"#架设HTTP服务\" class=\"headerlink\" title=\"架设HTTP服务\"></a>架设HTTP服务</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<p>这里的 app.listen(…) 方法只是以下方法的语法糖:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const http = require(&apos;http&apos;);</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">http.createServer(app.callback()).listen(3000);</span><br></pre></td></tr></table></figure>\n<p>这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const http = require(&apos;http&apos;);</span><br><span class=\"line\">const https = require(&apos;https&apos;);</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">http.createServer(app.callback()).listen(3000);</span><br><span class=\"line\">https.createServer(app.callback()).listen(3001);</span><br></pre></td></tr></table></figure>\n<h3 id=\"上下文对象-Context\"><a href=\"#上下文对象-Context\" class=\"headerlink\" title=\"上下文对象 Context\"></a>上下文对象 Context</h3><hr>\n<p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx; \t\t\t// 这是 Context</span><br><span class=\"line\">  \tctx.req; \t\t// 这是 Node Request</span><br><span class=\"line\">  \tctx.res; \t\t// 这是 Node Response  绕过 Koa 的 response 处理是 不被支持的. </span><br><span class=\"line\">  \tctx.request; \t// 这是 koa Request</span><br><span class=\"line\">  \tctx.response; \t// 这是 koa Response</span><br><span class=\"line\"></span><br><span class=\"line\">  \tctx.request.header   \t//请求标头对象。</span><br><span class=\"line\">  \tctx.request.header=   \t//设置请求标头对象。</span><br><span class=\"line\">  \tctx.request.method   \t//请求方法。</span><br><span class=\"line\">  \tctx.request.method=   \t//设置请求方法，对于实现诸如 methodOverride() 的中间件是有用的。</span><br><span class=\"line\">  \tctx.request.length   \t//返回以数字返回请求的 Content-Length，或 undefined。</span><br><span class=\"line\">  \tctx.request.url   \t\t//获取请求 URL.</span><br><span class=\"line\">  \tctx.request.url=    \t//设置请求 URL, 对 url 重写有用。</span><br><span class=\"line\">  \tctx.request.origin   \t//获取URL的来源，包括 protocol 和 host。</span><br><span class=\"line\">  \tctx.request.href    \t//获取完整的请求URL，包括 protocol，host 和 url。</span><br><span class=\"line\">  \tctx.request.path   \t    //获取请求路径名。</span><br><span class=\"line\">  \tctx.request.querystring //根据 ? 获取原始查询字符串.</span><br><span class=\"line\">  \tctx.request.search   \t//使用 ? 获取原始查询字符串。</span><br><span class=\"line\">  \tctx.request.query   \t//获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter 不 支持嵌套解析。</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Context.response.body属性就是发送给用户的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.response.type = &apos;json / xml / html / text&apos;; //这些都是response的类型</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = fs.createReadStream(&apos;./demos/template.html&apos;);</span><br><span class=\"line\">&#125;;    //返回一个网页模板</span><br></pre></td></tr></table></figure>\n<p>ctx.cookies用来读写 Cookie</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = function(ctx) &#123;</span><br><span class=\"line\"> \t\tconst n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;</span><br><span class=\"line\"> \t\tctx.cookies.set(&apos;view&apos;, n);</span><br><span class=\"line\"> \t\tctx.response.body = n + &apos; views&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><hr>\n<p>这里使用koa自带的koa-route 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const route = require(&apos;koa-route&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const about = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(&apos;/&apos;, main));</span><br><span class=\"line\">app.use(route.get(&apos;/about&apos;, about));</span><br></pre></td></tr></table></figure>\n<p>静态资源访问则使用koa自带的koa-static模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const path = require(&apos;path&apos;);</span><br><span class=\"line\">const serve = require(&apos;koa-static&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const main = serve(path.join(__dirname));</span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>重定向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const redirect = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.response.redirect(&apos;/&apos;);</span><br><span class=\"line\"> \t\tctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(&apos;/redirect&apos;, redirect));  //访问&apos;/redirect&apos;的请求会被重定向到&apos;/&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><hr>\n<p>基本上，Koa 所有的功能都是通过中间件实现的。<br>中间件的实现很简单，所谓中间件可以看做是有两个参数的函数，用来在 HTTP Request 和 HTTP Response 中间实现某种功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一个非常简单的输出log的中间件函数</span><br><span class=\"line\">   const logger = (ctx, next) =&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`);</span><br><span class=\"line\"> \t\tnext();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.use(logger);</span><br></pre></td></tr></table></figure>\n<p>如果对进程添加很多中间件的话会怎么样呢？<br>多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。</p>\n<p>也就是说，会从上至下依次进入每个中间件，但只有在最内层中间件执行完毕后才会一层层返回到最外层中间件，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const one = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; one&apos;);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; one&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; two&apos;);</span><br><span class=\"line\">  \tnext(); </span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; two&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; three&apos;);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; three&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(one);</span><br><span class=\"line\">app.use(two);</span><br><span class=\"line\">app.use(three);</span><br></pre></td></tr></table></figure>\n<p>此时的输出应该是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; one</span><br><span class=\"line\">&gt;&gt; two</span><br><span class=\"line\">&gt;&gt; three</span><br><span class=\"line\">&lt;&lt; three</span><br><span class=\"line\">&lt;&lt; two</span><br><span class=\"line\">&lt;&lt; one</span><br></pre></td></tr></table></figure>\n<p>这是全同步中间件的执行流程，如果这些中间件中包含异步操作，那么执行的流程就会发生变化</p>\n<p>首先，包含异步操作的中间件必须写成async函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这就是一个异步中间件</span><br><span class=\"line\">const main = async function (ctx, next) &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>中间件的合成则可以使用 koa-compose 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const compose = require(&apos;koa-compose&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const logger = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const middlewares = compose([logger, main]);</span><br><span class=\"line\">app.use(middlewares);</span><br></pre></td></tr></table></figure>\n<p>从 POST 请求的数据体里面提取键值对使用 koa-body 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const koaBody = require(&apos;koa-body&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const main = async function(ctx) &#123;</span><br><span class=\"line\">  \tconst body = ctx.request.body;</span><br><span class=\"line\">  \tif (!body.name) ctx.throw(400, &apos;.name required&apos;);</span><br><span class=\"line\">  \tctx.body = &#123; name: body.name &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(koaBody());</span><br></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><hr>\n<p>直接抛出错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.throw(500);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>返回错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.response.status = 404;</span><br><span class=\"line\"> \t\tctx.response.body = &apos;Page Not Found&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了方便处理错误，最好使用try…catch将其捕获。但是，为每个中间件都写try…catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const handler = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \ttry &#123;</span><br><span class=\"line\">    \tawait next();</span><br><span class=\"line\">  \t&#125;catch (err) &#123;</span><br><span class=\"line\">    \tctx.response.status = err.statusCode || err.status || 500;</span><br><span class=\"line\">    \tctx.response.body = &#123;</span><br><span class=\"line\">      \t\tmessage: err.message</span><br><span class=\"line\">    \t&#125;;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.throw(500);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(handler);</span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>app监听错误的处理方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.on(&apos;error&apos;, (err, ctx) =&gt;</span><br><span class=\"line\"> \t\tconsole.error(&apos;server error&apos;, err);</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果错误被try…catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const handler = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \ttry &#123;</span><br><span class=\"line\">    \tawait next();</span><br><span class=\"line\">  \t&#125; catch (err) &#123;</span><br><span class=\"line\">    \tctx.response.status = err.statusCode || err.status || 500;</span><br><span class=\"line\">    \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">    \tctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;</span><br><span class=\"line\">    \tctx.app.emit(&apos;error&apos;, err, ctx);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\" target=\"_blank\" rel=\"noopener\">阮一峰koa教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个系列将记载我在学习Koa过程中需要记录下来的重点和遇到的问题。<br><a href=\"https://koa.bootcss.com/\" target=\"_blank\" rel=\"noopener\">中文文档</a><br><a href=\"http://koajs.com\" target=\"_blank\" rel=\"noopener\">英文文档</a></p>\n<hr>\n<h3 id=\"安装koa\"><a href=\"#安装koa\" class=\"headerlink\" title=\"安装koa\"></a>安装koa</h3><hr>\n<p>Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持</p>\n<p>这里提供将升级本地node版本的方法</p>\n<p>先查看本机node.js版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n<p>清除node.js的cache：(此步会要求输入密码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm cache clean -f</span><br></pre></td></tr></table></figure>\n<p>安装 n 工具，这个工具是专门用来管理node.js版本的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g n</span><br></pre></td></tr></table></figure>\n<p>安装最新版本的node.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo n stable</span><br></pre></td></tr></table></figure>\n<p>再次查看本机的node.js版本：(本文采用的node版本为9.4.0)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n<p>安装koa</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i koa</span><br></pre></td></tr></table></figure>\n<h3 id=\"架设HTTP服务\"><a href=\"#架设HTTP服务\" class=\"headerlink\" title=\"架设HTTP服务\"></a>架设HTTP服务</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<p>这里的 app.listen(…) 方法只是以下方法的语法糖:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const http = require(&apos;http&apos;);</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">http.createServer(app.callback()).listen(3000);</span><br></pre></td></tr></table></figure>\n<p>这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const http = require(&apos;http&apos;);</span><br><span class=\"line\">const https = require(&apos;https&apos;);</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">http.createServer(app.callback()).listen(3000);</span><br><span class=\"line\">https.createServer(app.callback()).listen(3001);</span><br></pre></td></tr></table></figure>\n<h3 id=\"上下文对象-Context\"><a href=\"#上下文对象-Context\" class=\"headerlink\" title=\"上下文对象 Context\"></a>上下文对象 Context</h3><hr>\n<p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx; \t\t\t// 这是 Context</span><br><span class=\"line\">  \tctx.req; \t\t// 这是 Node Request</span><br><span class=\"line\">  \tctx.res; \t\t// 这是 Node Response  绕过 Koa 的 response 处理是 不被支持的. </span><br><span class=\"line\">  \tctx.request; \t// 这是 koa Request</span><br><span class=\"line\">  \tctx.response; \t// 这是 koa Response</span><br><span class=\"line\"></span><br><span class=\"line\">  \tctx.request.header   \t//请求标头对象。</span><br><span class=\"line\">  \tctx.request.header=   \t//设置请求标头对象。</span><br><span class=\"line\">  \tctx.request.method   \t//请求方法。</span><br><span class=\"line\">  \tctx.request.method=   \t//设置请求方法，对于实现诸如 methodOverride() 的中间件是有用的。</span><br><span class=\"line\">  \tctx.request.length   \t//返回以数字返回请求的 Content-Length，或 undefined。</span><br><span class=\"line\">  \tctx.request.url   \t\t//获取请求 URL.</span><br><span class=\"line\">  \tctx.request.url=    \t//设置请求 URL, 对 url 重写有用。</span><br><span class=\"line\">  \tctx.request.origin   \t//获取URL的来源，包括 protocol 和 host。</span><br><span class=\"line\">  \tctx.request.href    \t//获取完整的请求URL，包括 protocol，host 和 url。</span><br><span class=\"line\">  \tctx.request.path   \t    //获取请求路径名。</span><br><span class=\"line\">  \tctx.request.querystring //根据 ? 获取原始查询字符串.</span><br><span class=\"line\">  \tctx.request.search   \t//使用 ? 获取原始查询字符串。</span><br><span class=\"line\">  \tctx.request.query   \t//获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter 不 支持嵌套解析。</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Context.response.body属性就是发送给用户的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.response.type = &apos;json / xml / html / text&apos;; //这些都是response的类型</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = fs.createReadStream(&apos;./demos/template.html&apos;);</span><br><span class=\"line\">&#125;;    //返回一个网页模板</span><br></pre></td></tr></table></figure>\n<p>ctx.cookies用来读写 Cookie</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = function(ctx) &#123;</span><br><span class=\"line\"> \t\tconst n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;</span><br><span class=\"line\"> \t\tctx.cookies.set(&apos;view&apos;, n);</span><br><span class=\"line\"> \t\tctx.response.body = n + &apos; views&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><hr>\n<p>这里使用koa自带的koa-route 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const route = require(&apos;koa-route&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const about = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(&apos;/&apos;, main));</span><br><span class=\"line\">app.use(route.get(&apos;/about&apos;, about));</span><br></pre></td></tr></table></figure>\n<p>静态资源访问则使用koa自带的koa-static模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const path = require(&apos;path&apos;);</span><br><span class=\"line\">const serve = require(&apos;koa-static&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const main = serve(path.join(__dirname));</span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>重定向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   const redirect = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.response.redirect(&apos;/&apos;);</span><br><span class=\"line\"> \t\tctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(&apos;/redirect&apos;, redirect));  //访问&apos;/redirect&apos;的请求会被重定向到&apos;/&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><hr>\n<p>基本上，Koa 所有的功能都是通过中间件实现的。<br>中间件的实现很简单，所谓中间件可以看做是有两个参数的函数，用来在 HTTP Request 和 HTTP Response 中间实现某种功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一个非常简单的输出log的中间件函数</span><br><span class=\"line\">   const logger = (ctx, next) =&gt; &#123;</span><br><span class=\"line\"> \t\tconsole.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`);</span><br><span class=\"line\"> \t\tnext();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.use(logger);</span><br></pre></td></tr></table></figure>\n<p>如果对进程添加很多中间件的话会怎么样呢？<br>多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。</p>\n<p>也就是说，会从上至下依次进入每个中间件，但只有在最内层中间件执行完毕后才会一层层返回到最外层中间件，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const one = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; one&apos;);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; one&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; two&apos;);</span><br><span class=\"line\">  \tnext(); </span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; two&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(&apos;&gt;&gt; three&apos;);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">  \tconsole.log(&apos;&lt;&lt; three&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(one);</span><br><span class=\"line\">app.use(two);</span><br><span class=\"line\">app.use(three);</span><br></pre></td></tr></table></figure>\n<p>此时的输出应该是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; one</span><br><span class=\"line\">&gt;&gt; two</span><br><span class=\"line\">&gt;&gt; three</span><br><span class=\"line\">&lt;&lt; three</span><br><span class=\"line\">&lt;&lt; two</span><br><span class=\"line\">&lt;&lt; one</span><br></pre></td></tr></table></figure>\n<p>这是全同步中间件的执行流程，如果这些中间件中包含异步操作，那么执行的流程就会发生变化</p>\n<p>首先，包含异步操作的中间件必须写成async函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这就是一个异步中间件</span><br><span class=\"line\">const main = async function (ctx, next) &#123;</span><br><span class=\"line\">  \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">  \tctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>中间件的合成则可以使用 koa-compose 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const compose = require(&apos;koa-compose&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const logger = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \tconsole.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`);</span><br><span class=\"line\">  \tnext();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.response.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const middlewares = compose([logger, main]);</span><br><span class=\"line\">app.use(middlewares);</span><br></pre></td></tr></table></figure>\n<p>从 POST 请求的数据体里面提取键值对使用 koa-body 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const koaBody = require(&apos;koa-body&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const main = async function(ctx) &#123;</span><br><span class=\"line\">  \tconst body = ctx.request.body;</span><br><span class=\"line\">  \tif (!body.name) ctx.throw(400, &apos;.name required&apos;);</span><br><span class=\"line\">  \tctx.body = &#123; name: body.name &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(koaBody());</span><br></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><hr>\n<p>直接抛出错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.throw(500);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>返回错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\"> \t\tctx.response.status = 404;</span><br><span class=\"line\"> \t\tctx.response.body = &apos;Page Not Found&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了方便处理错误，最好使用try…catch将其捕获。但是，为每个中间件都写try…catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const handler = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \ttry &#123;</span><br><span class=\"line\">    \tawait next();</span><br><span class=\"line\">  \t&#125;catch (err) &#123;</span><br><span class=\"line\">    \tctx.response.status = err.statusCode || err.status || 500;</span><br><span class=\"line\">    \tctx.response.body = &#123;</span><br><span class=\"line\">      \t\tmessage: err.message</span><br><span class=\"line\">    \t&#125;;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const main = ctx =&gt; &#123;</span><br><span class=\"line\">  \tctx.throw(500);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(handler);</span><br><span class=\"line\">app.use(main);</span><br></pre></td></tr></table></figure>\n<p>app监听错误的处理方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.on(&apos;error&apos;, (err, ctx) =&gt;</span><br><span class=\"line\"> \t\tconsole.error(&apos;server error&apos;, err);</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果错误被try…catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const handler = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  \ttry &#123;</span><br><span class=\"line\">    \tawait next();</span><br><span class=\"line\">  \t&#125; catch (err) &#123;</span><br><span class=\"line\">    \tctx.response.status = err.statusCode || err.status || 500;</span><br><span class=\"line\">    \tctx.response.type = &apos;html&apos;;</span><br><span class=\"line\">    \tctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;</span><br><span class=\"line\">    \tctx.app.emit(&apos;error&apos;, err, ctx);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\" target=\"_blank\" rel=\"noopener\">阮一峰koa教程</a></p>\n"},{"layout":"post","title":"Node.js系列(mongoose的学习笔记 一)","subtitle":"mongoose的基础知识","date":"2017-12-23T16:00:00.000Z","author":"Ai Shuangying","header-img":"hack.jpeg","cdn":"header-on","_content":"\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在学习Node.js中常用的包相关的内容，作为以后工作中的备忘笔记。\n[官方文档](http://mongoosejs.com/docs/api.html)\n[社区文档](http://www.nodeclass.com/api/mongoose.html)\n\n----------\n\n\n### 安装mongoose\n-------------\n\n```\n    npm install mongoose\n```\n\n### 连接mongoose\n-------------\n\n```\n    var mongoose = require('mongoose');\n\n    mongoose.connect('mongodb://<dbuser>:<dbpassword>@ds147681.mlab.com:47681/aishuangying');\n\n    var db = mongoose.connection;\n\n    db.on('error', console.error.bind(console, 'connection error:'));\n    db.once('open', function (callback) {\n        console.log('connect success');\n    });\n```\n[点击这里](http://www.nodeclass.com/api/mongoose.html#connection-js)文档了解更多connection事件\n\n### Schema\n-------------\nSchema是mongoose的定义表结构的数据模式。\n每个Schema会映射到mongodb中的一个collection，但是它不具备操作数据库的能力。\n定义Schema\n\n```\n    var Schema = mongoose.Schema;         //这里的mongoose就是上面初始化好的mongoose变量\n\n    var OneSchema = new Schema({          \n        username : { type: String },\n        userpwd: {type: String},\n        userage: {type: Number},\n        logindate : { type: Date}\n    });\n```\n[点击这里](http://www.nodeclass.com/api/mongoose.html#schematype-js)文档了解更多Schema类型\n\n### Model\n-------------\n定义好Schema之后生成Model\nmodel是由schema生成的模型，可以对数据库的操作\n我们对上面的定义的user的schema生成一个User的model并导出，修改后代码如下\n\n```\n    var oneModel = mongoose.model('newUser',OneSchema);\n```\n这里的'User'就是数据库中对应的Collection名称\n\n### 常用的数据库操作\n-------------\n\n插入数据库\n\n```\n    function insert() {\n        var one = new oneModel({\n            username : 'Tracy McGrady',                 //用户账号\n            userpwd: 'abcd',                            //密码\n            userage: 37,                                //年龄\n            logindate : new Date(),                      //最近登录时间\n            updateTime : new Date()\n        });\n        one.save(function (err, res) {\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        });\n    }\n    insert();\n```\n更新数据库\n\n```\n    function update(){\n        var wherestr = {'username' : 'Tracy McGrady'}\n        var updateinfo = {'updateTime' : new Date()};\n        \n        oneModel.update(wherestr, updateinfo , function(err, res){\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        })\n    }\n    update();\n```\n更新规则，在这类model中按名称来更新updateTime属性。\n查询\n\n```\n    function getByConditions(){\n        var wherestr = {'username' : 'Tracy McGrady'};\n    \n        oneModel.find(wherestr, function(err, res){\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        })\n    }   \n    getByConditions();\n```\n返回的res为\n```\n    { \n        _id: 5a3f6664b2938f0517a2fa2e,\n        username: 'Tracy McGrady',\n        userpwd: 'abcd',\n        userage: 37,\n        logindate: 2017-12-24T08:33:40.714Z,\n        updateTime: 2017-12-24T08:35:48.898Z,\n        __v: 0 \n    }\n```\n第2个参数可以设置要查询输出的字段,比如 var opt = {\"username\": 1 ,\"_id\": 0};\n返回的res为\n```\n    { username: 'Tracy McGrady' }\n```\n比如我要查询年龄范围条件应该怎么写呢？\n```\n    oneModel.find({userage: {$gte: 21, $lte: 65}}, callback);    //这表示查询年龄大于等21而且小于等于65岁\n```\n其实类似的还有：　\n\n　　$or　　　　       或关系\n　　$nor　　　        或关系取反\n　　$gt　　　　       大于\n　　$gte　　　        大于等于\n　　$lt　　　　       小于\n　　$lte　　　        小于等于\n　　$ne              不等于\n　　$in              在多个值范围内\n　　$nin             不在多个值范围内\n　　$all             匹配数组中多个值\n　　$regex　　        正则，用于模糊查询\n　　$size　　　       匹配数组大小\n　　$maxDistance　   范围查询，距离（基于LBS）\n　　$mod　　         取模运算\n　　$near　　　       邻域查询，查询附近的位置（基于LBS）\n　　$exists　　      字段是否存在\n　　$elemMatch　　   匹配内数组内的元素\n　　$within　　      范围查询（基于LBS）\n　　$box　　　       范围查询，矩形范围（基于LBS）\n　　$center         范围醒询，圆形范围（基于LBS）\n　　$centerSphere　　范围查询，球形范围（基于LBS）\n　　$slice　　　　    查询字段集合中的元素（比如从第几个之后，第N到第M个元素）\n建索引和设置默认值\n\n```\n    var UserSchema = new Schema({          \n        username : { type: String , index: true},  \n        userpwd: {type: String},                    \n        userage: {type: Number},                   \n        logindate : { type: Date, default:Date.now} \n    });\n```\n　\n\n更多的操作，查询[官方文档](http://www.nodeclass.com/api/mongoose.html#model-js)","source":"_posts/node_mongoose_1.md","raw":"---\nlayout: post\ntitle: \"Node.js系列(mongoose的学习笔记 一)\"\nsubtitle: \"mongoose的基础知识\"\ndate: 2017-12-24\nauthor: \"Ai Shuangying\"\nheader-img: \"hack.jpeg\"\ncdn: 'header-on'\ntags: \n    - Node.js\n    - MongoDB\n---\n\n<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n\n\n这个系列将记载我在学习Node.js中常用的包相关的内容，作为以后工作中的备忘笔记。\n[官方文档](http://mongoosejs.com/docs/api.html)\n[社区文档](http://www.nodeclass.com/api/mongoose.html)\n\n----------\n\n\n### 安装mongoose\n-------------\n\n```\n    npm install mongoose\n```\n\n### 连接mongoose\n-------------\n\n```\n    var mongoose = require('mongoose');\n\n    mongoose.connect('mongodb://<dbuser>:<dbpassword>@ds147681.mlab.com:47681/aishuangying');\n\n    var db = mongoose.connection;\n\n    db.on('error', console.error.bind(console, 'connection error:'));\n    db.once('open', function (callback) {\n        console.log('connect success');\n    });\n```\n[点击这里](http://www.nodeclass.com/api/mongoose.html#connection-js)文档了解更多connection事件\n\n### Schema\n-------------\nSchema是mongoose的定义表结构的数据模式。\n每个Schema会映射到mongodb中的一个collection，但是它不具备操作数据库的能力。\n定义Schema\n\n```\n    var Schema = mongoose.Schema;         //这里的mongoose就是上面初始化好的mongoose变量\n\n    var OneSchema = new Schema({          \n        username : { type: String },\n        userpwd: {type: String},\n        userage: {type: Number},\n        logindate : { type: Date}\n    });\n```\n[点击这里](http://www.nodeclass.com/api/mongoose.html#schematype-js)文档了解更多Schema类型\n\n### Model\n-------------\n定义好Schema之后生成Model\nmodel是由schema生成的模型，可以对数据库的操作\n我们对上面的定义的user的schema生成一个User的model并导出，修改后代码如下\n\n```\n    var oneModel = mongoose.model('newUser',OneSchema);\n```\n这里的'User'就是数据库中对应的Collection名称\n\n### 常用的数据库操作\n-------------\n\n插入数据库\n\n```\n    function insert() {\n        var one = new oneModel({\n            username : 'Tracy McGrady',                 //用户账号\n            userpwd: 'abcd',                            //密码\n            userage: 37,                                //年龄\n            logindate : new Date(),                      //最近登录时间\n            updateTime : new Date()\n        });\n        one.save(function (err, res) {\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        });\n    }\n    insert();\n```\n更新数据库\n\n```\n    function update(){\n        var wherestr = {'username' : 'Tracy McGrady'}\n        var updateinfo = {'updateTime' : new Date()};\n        \n        oneModel.update(wherestr, updateinfo , function(err, res){\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        })\n    }\n    update();\n```\n更新规则，在这类model中按名称来更新updateTime属性。\n查询\n\n```\n    function getByConditions(){\n        var wherestr = {'username' : 'Tracy McGrady'};\n    \n        oneModel.find(wherestr, function(err, res){\n            if (err) {\n                console.log(\"Error:\" + err);\n            }\n            else {\n                console.log(\"Res:\" + res);\n            }\n        })\n    }   \n    getByConditions();\n```\n返回的res为\n```\n    { \n        _id: 5a3f6664b2938f0517a2fa2e,\n        username: 'Tracy McGrady',\n        userpwd: 'abcd',\n        userage: 37,\n        logindate: 2017-12-24T08:33:40.714Z,\n        updateTime: 2017-12-24T08:35:48.898Z,\n        __v: 0 \n    }\n```\n第2个参数可以设置要查询输出的字段,比如 var opt = {\"username\": 1 ,\"_id\": 0};\n返回的res为\n```\n    { username: 'Tracy McGrady' }\n```\n比如我要查询年龄范围条件应该怎么写呢？\n```\n    oneModel.find({userage: {$gte: 21, $lte: 65}}, callback);    //这表示查询年龄大于等21而且小于等于65岁\n```\n其实类似的还有：　\n\n　　$or　　　　       或关系\n　　$nor　　　        或关系取反\n　　$gt　　　　       大于\n　　$gte　　　        大于等于\n　　$lt　　　　       小于\n　　$lte　　　        小于等于\n　　$ne              不等于\n　　$in              在多个值范围内\n　　$nin             不在多个值范围内\n　　$all             匹配数组中多个值\n　　$regex　　        正则，用于模糊查询\n　　$size　　　       匹配数组大小\n　　$maxDistance　   范围查询，距离（基于LBS）\n　　$mod　　         取模运算\n　　$near　　　       邻域查询，查询附近的位置（基于LBS）\n　　$exists　　      字段是否存在\n　　$elemMatch　　   匹配内数组内的元素\n　　$within　　      范围查询（基于LBS）\n　　$box　　　       范围查询，矩形范围（基于LBS）\n　　$center         范围醒询，圆形范围（基于LBS）\n　　$centerSphere　　范围查询，球形范围（基于LBS）\n　　$slice　　　　    查询字段集合中的元素（比如从第几个之后，第N到第M个元素）\n建索引和设置默认值\n\n```\n    var UserSchema = new Schema({          \n        username : { type: String , index: true},  \n        userpwd: {type: String},                    \n        userage: {type: Number},                   \n        logindate : { type: Date, default:Date.now} \n    });\n```\n　\n\n更多的操作，查询[官方文档](http://www.nodeclass.com/api/mongoose.html#model-js)","slug":"node_mongoose_1","published":1,"updated":"2018-01-14T12:21:08.849Z","comments":1,"photos":[],"link":"","_id":"cjciskgdq0004n3farkuz5mof","content":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在学习Node.js中常用的包相关的内容，作为以后工作中的备忘笔记。<br><a href=\"http://mongoosejs.com/docs/api.html\" target=\"_blank\" rel=\"noopener\">官方文档</a><br><a href=\"http://www.nodeclass.com/api/mongoose.html\" target=\"_blank\" rel=\"noopener\">社区文档</a></p>\n<hr>\n<h3 id=\"安装mongoose\"><a href=\"#安装mongoose\" class=\"headerlink\" title=\"安装mongoose\"></a>安装mongoose</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接mongoose\"><a href=\"#连接mongoose\" class=\"headerlink\" title=\"连接mongoose\"></a>连接mongoose</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require(&apos;mongoose&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.connect(&apos;mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds147681.mlab.com:47681/aishuangying&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var db = mongoose.connection;</span><br><span class=\"line\"></span><br><span class=\"line\">db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;));</span><br><span class=\"line\">db.once(&apos;open&apos;, function (callback) &#123;</span><br><span class=\"line\">    console.log(&apos;connect success&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.nodeclass.com/api/mongoose.html#connection-js\" target=\"_blank\" rel=\"noopener\">点击这里</a>文档了解更多connection事件</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a>Schema</h3><hr>\n<p>Schema是mongoose的定义表结构的数据模式。<br>每个Schema会映射到mongodb中的一个collection，但是它不具备操作数据库的能力。<br>定义Schema</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Schema = mongoose.Schema;         //这里的mongoose就是上面初始化好的mongoose变量</span><br><span class=\"line\"></span><br><span class=\"line\">var OneSchema = new Schema(&#123;          </span><br><span class=\"line\">    username : &#123; type: String &#125;,</span><br><span class=\"line\">    userpwd: &#123;type: String&#125;,</span><br><span class=\"line\">    userage: &#123;type: Number&#125;,</span><br><span class=\"line\">    logindate : &#123; type: Date&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.nodeclass.com/api/mongoose.html#schematype-js\" target=\"_blank\" rel=\"noopener\">点击这里</a>文档了解更多Schema类型</p>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><hr>\n<p>定义好Schema之后生成Model<br>model是由schema生成的模型，可以对数据库的操作<br>我们对上面的定义的user的schema生成一个User的model并导出，修改后代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var oneModel = mongoose.model(&apos;newUser&apos;,OneSchema);</span><br></pre></td></tr></table></figure>\n<p>这里的’User’就是数据库中对应的Collection名称</p>\n<h3 id=\"常用的数据库操作\"><a href=\"#常用的数据库操作\" class=\"headerlink\" title=\"常用的数据库操作\"></a>常用的数据库操作</h3><hr>\n<p>插入数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function insert() &#123;</span><br><span class=\"line\">    var one = new oneModel(&#123;</span><br><span class=\"line\">        username : &apos;Tracy McGrady&apos;,                 //用户账号</span><br><span class=\"line\">        userpwd: &apos;abcd&apos;,                            //密码</span><br><span class=\"line\">        userage: 37,                                //年龄</span><br><span class=\"line\">        logindate : new Date(),                      //最近登录时间</span><br><span class=\"line\">        updateTime : new Date()</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    one.save(function (err, res) &#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">insert();</span><br></pre></td></tr></table></figure>\n<p>更新数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function update()&#123;</span><br><span class=\"line\">    var wherestr = &#123;&apos;username&apos; : &apos;Tracy McGrady&apos;&#125;</span><br><span class=\"line\">    var updateinfo = &#123;&apos;updateTime&apos; : new Date()&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oneModel.update(wherestr, updateinfo , function(err, res)&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">update();</span><br></pre></td></tr></table></figure>\n<p>更新规则，在这类model中按名称来更新updateTime属性。<br>查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getByConditions()&#123;</span><br><span class=\"line\">    var wherestr = &#123;&apos;username&apos; : &apos;Tracy McGrady&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    oneModel.find(wherestr, function(err, res)&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">getByConditions();</span><br></pre></td></tr></table></figure>\n<p>返回的res为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    _id: 5a3f6664b2938f0517a2fa2e,</span><br><span class=\"line\">    username: &apos;Tracy McGrady&apos;,</span><br><span class=\"line\">    userpwd: &apos;abcd&apos;,</span><br><span class=\"line\">    userage: 37,</span><br><span class=\"line\">    logindate: 2017-12-24T08:33:40.714Z,</span><br><span class=\"line\">    updateTime: 2017-12-24T08:35:48.898Z,</span><br><span class=\"line\">    __v: 0 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第2个参数可以设置要查询输出的字段,比如 var opt = {“username”: 1 ,”_id”: 0};<br>返回的res为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; username: &apos;Tracy McGrady&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>比如我要查询年龄范围条件应该怎么写呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oneModel.find(&#123;userage: &#123;$gte: 21, $lte: 65&#125;&#125;, callback);    //这表示查询年龄大于等21而且小于等于65岁</span><br></pre></td></tr></table></figure></p>\n<p>其实类似的还有：　</p>\n<p>　　$or　　　　       或关系<br>　　$nor　　　        或关系取反<br>　　$gt　　　　       大于<br>　　$gte　　　        大于等于<br>　　$lt　　　　       小于<br>　　$lte　　　        小于等于<br>　　$ne              不等于<br>　　$in              在多个值范围内<br>　　$nin             不在多个值范围内<br>　　$all             匹配数组中多个值<br>　　$regex　　        正则，用于模糊查询<br>　　$size　　　       匹配数组大小<br>　　$maxDistance　   范围查询，距离（基于LBS）<br>　　$mod　　         取模运算<br>　　$near　　　       邻域查询，查询附近的位置（基于LBS）<br>　　$exists　　      字段是否存在<br>　　$elemMatch　　   匹配内数组内的元素<br>　　$within　　      范围查询（基于LBS）<br>　　$box　　　       范围查询，矩形范围（基于LBS）<br>　　$center         范围醒询，圆形范围（基于LBS）<br>　　$centerSphere　　范围查询，球形范围（基于LBS）<br>　　$slice　　　　    查询字段集合中的元素（比如从第几个之后，第N到第M个元素）<br>建索引和设置默认值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UserSchema = new Schema(&#123;          </span><br><span class=\"line\">    username : &#123; type: String , index: true&#125;,  </span><br><span class=\"line\">    userpwd: &#123;type: String&#125;,                    </span><br><span class=\"line\">    userage: &#123;type: Number&#125;,                   </span><br><span class=\"line\">    logindate : &#123; type: Date, default:Date.now&#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>　</p>\n<p>更多的操作，查询<a href=\"http://www.nodeclass.com/api/mongoose.html#model-js\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<!-- LeetCode刷题系列(1)(question 3)\n=================== -->\n<p>这个系列将记载我在学习Node.js中常用的包相关的内容，作为以后工作中的备忘笔记。<br><a href=\"http://mongoosejs.com/docs/api.html\" target=\"_blank\" rel=\"noopener\">官方文档</a><br><a href=\"http://www.nodeclass.com/api/mongoose.html\" target=\"_blank\" rel=\"noopener\">社区文档</a></p>\n<hr>\n<h3 id=\"安装mongoose\"><a href=\"#安装mongoose\" class=\"headerlink\" title=\"安装mongoose\"></a>安装mongoose</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接mongoose\"><a href=\"#连接mongoose\" class=\"headerlink\" title=\"连接mongoose\"></a>连接mongoose</h3><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require(&apos;mongoose&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.connect(&apos;mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds147681.mlab.com:47681/aishuangying&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var db = mongoose.connection;</span><br><span class=\"line\"></span><br><span class=\"line\">db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;));</span><br><span class=\"line\">db.once(&apos;open&apos;, function (callback) &#123;</span><br><span class=\"line\">    console.log(&apos;connect success&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.nodeclass.com/api/mongoose.html#connection-js\" target=\"_blank\" rel=\"noopener\">点击这里</a>文档了解更多connection事件</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a>Schema</h3><hr>\n<p>Schema是mongoose的定义表结构的数据模式。<br>每个Schema会映射到mongodb中的一个collection，但是它不具备操作数据库的能力。<br>定义Schema</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Schema = mongoose.Schema;         //这里的mongoose就是上面初始化好的mongoose变量</span><br><span class=\"line\"></span><br><span class=\"line\">var OneSchema = new Schema(&#123;          </span><br><span class=\"line\">    username : &#123; type: String &#125;,</span><br><span class=\"line\">    userpwd: &#123;type: String&#125;,</span><br><span class=\"line\">    userage: &#123;type: Number&#125;,</span><br><span class=\"line\">    logindate : &#123; type: Date&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.nodeclass.com/api/mongoose.html#schematype-js\" target=\"_blank\" rel=\"noopener\">点击这里</a>文档了解更多Schema类型</p>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><hr>\n<p>定义好Schema之后生成Model<br>model是由schema生成的模型，可以对数据库的操作<br>我们对上面的定义的user的schema生成一个User的model并导出，修改后代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var oneModel = mongoose.model(&apos;newUser&apos;,OneSchema);</span><br></pre></td></tr></table></figure>\n<p>这里的’User’就是数据库中对应的Collection名称</p>\n<h3 id=\"常用的数据库操作\"><a href=\"#常用的数据库操作\" class=\"headerlink\" title=\"常用的数据库操作\"></a>常用的数据库操作</h3><hr>\n<p>插入数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function insert() &#123;</span><br><span class=\"line\">    var one = new oneModel(&#123;</span><br><span class=\"line\">        username : &apos;Tracy McGrady&apos;,                 //用户账号</span><br><span class=\"line\">        userpwd: &apos;abcd&apos;,                            //密码</span><br><span class=\"line\">        userage: 37,                                //年龄</span><br><span class=\"line\">        logindate : new Date(),                      //最近登录时间</span><br><span class=\"line\">        updateTime : new Date()</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    one.save(function (err, res) &#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">insert();</span><br></pre></td></tr></table></figure>\n<p>更新数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function update()&#123;</span><br><span class=\"line\">    var wherestr = &#123;&apos;username&apos; : &apos;Tracy McGrady&apos;&#125;</span><br><span class=\"line\">    var updateinfo = &#123;&apos;updateTime&apos; : new Date()&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oneModel.update(wherestr, updateinfo , function(err, res)&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">update();</span><br></pre></td></tr></table></figure>\n<p>更新规则，在这类model中按名称来更新updateTime属性。<br>查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getByConditions()&#123;</span><br><span class=\"line\">    var wherestr = &#123;&apos;username&apos; : &apos;Tracy McGrady&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    oneModel.find(wherestr, function(err, res)&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&quot;Error:&quot; + err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            console.log(&quot;Res:&quot; + res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">getByConditions();</span><br></pre></td></tr></table></figure>\n<p>返回的res为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    _id: 5a3f6664b2938f0517a2fa2e,</span><br><span class=\"line\">    username: &apos;Tracy McGrady&apos;,</span><br><span class=\"line\">    userpwd: &apos;abcd&apos;,</span><br><span class=\"line\">    userage: 37,</span><br><span class=\"line\">    logindate: 2017-12-24T08:33:40.714Z,</span><br><span class=\"line\">    updateTime: 2017-12-24T08:35:48.898Z,</span><br><span class=\"line\">    __v: 0 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第2个参数可以设置要查询输出的字段,比如 var opt = {“username”: 1 ,”_id”: 0};<br>返回的res为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; username: &apos;Tracy McGrady&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>比如我要查询年龄范围条件应该怎么写呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oneModel.find(&#123;userage: &#123;$gte: 21, $lte: 65&#125;&#125;, callback);    //这表示查询年龄大于等21而且小于等于65岁</span><br></pre></td></tr></table></figure></p>\n<p>其实类似的还有：　</p>\n<p>　　$or　　　　       或关系<br>　　$nor　　　        或关系取反<br>　　$gt　　　　       大于<br>　　$gte　　　        大于等于<br>　　$lt　　　　       小于<br>　　$lte　　　        小于等于<br>　　$ne              不等于<br>　　$in              在多个值范围内<br>　　$nin             不在多个值范围内<br>　　$all             匹配数组中多个值<br>　　$regex　　        正则，用于模糊查询<br>　　$size　　　       匹配数组大小<br>　　$maxDistance　   范围查询，距离（基于LBS）<br>　　$mod　　         取模运算<br>　　$near　　　       邻域查询，查询附近的位置（基于LBS）<br>　　$exists　　      字段是否存在<br>　　$elemMatch　　   匹配内数组内的元素<br>　　$within　　      范围查询（基于LBS）<br>　　$box　　　       范围查询，矩形范围（基于LBS）<br>　　$center         范围醒询，圆形范围（基于LBS）<br>　　$centerSphere　　范围查询，球形范围（基于LBS）<br>　　$slice　　　　    查询字段集合中的元素（比如从第几个之后，第N到第M个元素）<br>建索引和设置默认值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UserSchema = new Schema(&#123;          </span><br><span class=\"line\">    username : &#123; type: String , index: true&#125;,  </span><br><span class=\"line\">    userpwd: &#123;type: String&#125;,                    </span><br><span class=\"line\">    userage: &#123;type: Number&#125;,                   </span><br><span class=\"line\">    logindate : &#123; type: Date, default:Date.now&#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>　</p>\n<p>更多的操作，查询<a href=\"http://www.nodeclass.com/api/mongoose.html#model-js\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjciskgdf0000n3fae346roxm","tag_id":"cjciskgdm0002n3favzfac445","_id":"cjciskgdt0006n3fac19c0vlr"},{"post_id":"cjciskgdk0001n3fa8l72gip3","tag_id":"cjciskgdm0002n3favzfac445","_id":"cjciskgdv0008n3faq9ym548h"},{"post_id":"cjciskgdo0003n3facwxcti62","tag_id":"cjciskgdu0007n3fax0ddmhtr","_id":"cjciskgdw000bn3faqqmhxk3g"},{"post_id":"cjciskgdo0003n3facwxcti62","tag_id":"cjciskgdv0009n3fave3k5fej","_id":"cjciskgdw000cn3fakd7fc4s8"},{"post_id":"cjciskgdq0004n3farkuz5mof","tag_id":"cjciskgdu0007n3fax0ddmhtr","_id":"cjciskgdx000en3faenv2wu01"},{"post_id":"cjciskgdq0004n3farkuz5mof","tag_id":"cjciskgdw000dn3fad6vmco32","_id":"cjciskgdx000fn3fa8rw9v51i"}],"Tag":[{"name":"LeetCode","_id":"cjciskgdm0002n3favzfac445"},{"name":"Node.js","_id":"cjciskgdu0007n3fax0ddmhtr"},{"name":"Koa","_id":"cjciskgdv0009n3fave3k5fej"},{"name":"MongoDB","_id":"cjciskgdw000dn3fad6vmco32"}]}}